#include <stdexcept>
#include "logparser.h"
#include <QFile>
#include <QTextStream>
#include <QRegularExpression>
#include <QDebug>
#include <QScopedPointer>
#include "blfparser.h"

class TextDriver
{
public:
    virtual bool parseLine(const QString &line, CanLogMsg &msg) = 0;
    QVector<CanLogMsg> parse(const QString &name)
    {
        QFile file(name);
        if (!file.open(QFile::ReadOnly | QFile::Text)) {
            throw std::runtime_error("Cannot open file");
        }
        QTextStream in(&file);
        auto ret = parse(in);
        file.close();
        return std::move(ret);
    }

    QVector<CanLogMsg> parse(QTextStream &in)
    {
        QVector<CanLogMsg> messages{};
        while (!in.atEnd()) {
            CanLogMsg msg;
            auto line = in.readLine();
            auto result = parseLine(line, msg);
            if (result) {
                messages.append(msg);
            }
        }
        return std::move(messages);
    }
    TextDriver() = default;
    virtual ~TextDriver() = default;
};

// ;$FILEVERSION=1.1
// ;$STARTTIME=45065.7038682292
// ;
// ;   Start time: 5/19/2023 16:53:34.215.0
// ;   Generated by PCAN-View v5.0.5.871
// ;
// ;   Message Number
// ;   |         Time Offset (ms)
// ;   |         |        Type
// ;   |         |        |        ID (hex)
// ;   |         |        |        |     Data Length
// ;   |         |        |        |     |   Data Bytes (hex) ...
// ;   |         |        |        |     |   |
// ;---+--   ----+----  --+--  ----+---  +  -+ -- -- -- -- -- -- --
//      1)    118912.2  Rx     0CF00300  8  03 00 00 00 00 00 00 00
//      2)    118912.5  Rx     18F00010  8  00 7D 00 00 00 00 00 7D
class TrcDriver : public TextDriver
{
public:
    TrcDriver()
        : re(R"(([0-9]+)\)\s+([0-9\.]+)\s+(Rx|Tx)\s+([0-9A-F]+)\s+([0-9]+)\s+([0-9 A-F]+))")
    {
    }
    bool parseLine(const QString &line, CanLogMsg &msg) override
    {
        if (line[0] == commentChar) {
            return false;
        }
        auto match = re.match(line);
        if (!match.hasMatch()) {
            qWarning() << "Cannot match " << line;
            return false;
        }
        QString result;
        bool ok = false;
        result = match.captured(numberOffset);
        msg.number = result.toInt(&ok);
        if (!ok) {
            return false;
        }
        result = match.captured(timeOffset);
        msg.time = result.toDouble(&ok);
        if (!ok) {
            return false;
        }
        msg.time /= timeScale;
        result = match.captured(dirOffset);
        if (!msg.setDir(result)) {
            return false;
        }
        result = match.captured(canIdOffset);
        msg.id = result.toUInt(&ok, 16);
        if (!ok) {
            return false;
        }
        result = match.captured(dlcOffset);
        msg.dlc = result.toUInt(&ok);
        if (!ok) {
            return false;
        }
        if (msg.dlc > CAN_MAX_DLC) {
            qWarning() << "Invalid dlc:" << msg.dlc;
            return false;
        }
        result = match.captured(dataOffset);
        result.remove(" ");
        auto data = QByteArray::fromHex(result.toUtf8());
        std::memcpy(msg.data.data(), data.constData(), data.size());
        msg.channel = 0;
        return true;
    }

private:
    static const char commentChar = ';';
    static const uint8_t numberOffset = 1;
    static const uint8_t timeOffset = 2;
    static const uint8_t dirOffset = 3;
    static const uint8_t canIdOffset = 4;
    static const uint8_t dlcOffset = 5;
    static const uint8_t dataOffset = 6;
    constexpr static const double timeScale = 1000.0;
    QRegularExpression re;
};

class AscDriver : public TextDriver
{
public:
    AscDriver()
        : re(R"(([\d.]+) +([\d]+)? +([0-9A-F]+)x? +(Rx|Tx) +d +([\d]+) +([0-9A-F ]+))"){};
    bool parseLine(const QString &line, CanLogMsg &msg) override
    {
        auto match = re.match(line);
        if (!match.hasMatch()) {
            return false;
        }
        QString result;
        bool ok = false;
        msg.number = number;
        result = match.captured(timeOffset);
        msg.time = result.toDouble(&ok);
        if (!ok) {
            return false;
        }
        result = match.captured(chanOffset);
        if (result == "") {
            msg.channel = 0;
        } else {
            msg.channel = result.toUInt();
        }
        result = match.captured(idOffset);
        msg.id = result.toULong(&ok, 16);
        if (!ok) {
            return false;
        }
        result = match.captured(dirOffset);
        if (!msg.setDir(result)) {
            return false;
        }
        result = match.captured(dlcOffset);
        msg.dlc = result.toUInt();
        if (msg.dlc > CAN_MAX_DLC) {
            return false;
        }
        result = match.captured(dataOffset);
        result.remove(" ");
        auto data = QByteArray::fromHex(result.toUtf8());
        std::memcpy(msg.data.data(), data.constData(), data.size());
        number += 1;
        return true;
    }

private:
    static constexpr uint8_t timeOffset = 1;
    static constexpr uint8_t chanOffset = 2;
    static constexpr uint8_t idOffset = 3;
    static constexpr uint8_t dirOffset = 4;
    static constexpr uint8_t dlcOffset = 5;
    static constexpr uint8_t dataOffset = 6;
    uint32_t number{ 0 };
    QRegularExpression re;
};

QString getExtension(const QString &name)
{
    auto lastDotIndex = name.lastIndexOf('.');
    if (lastDotIndex != -1 && lastDotIndex < name.length() - 1) {
        return name.mid(lastDotIndex + 1);
    }
    return "";
}

QVector<CanLogMsg> Parser::parse(const QString &name)
{
    std::unique_ptr<TextDriver> driver;
    auto extension = getExtension(name);
    bool isText = true;
    if (extension.compare("asc", Qt::CaseInsensitive) == 0) {
        // ASC file
        driver = std::make_unique<AscDriver>();
    } else if (extension.compare("trc", Qt::CaseInsensitive) == 0) {
        // Trc file
        driver = std::make_unique<TrcDriver>();
    } else if (extension.compare("blf", Qt::CaseInsensitive) == 0) {
        isText = false;
    }

    if (isText) {
        return driver->parse(name);
    } else {
        BlfParser parser;
        return parser.parse(name);
    }
}
